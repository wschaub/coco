
 ORG $3000
hello FCN "HELLO WORLD!123456789ABCDEFGHIJK" ; hello world string.
line1 FCN "THIS PROGRAM IS MEANT TO        " 
line2 FCN "SIMULATE TEXT PRINTED TO A TTY  "
sctext FCN "THIS IS A DEMO OFVSCROLLING TXT"
msg FCN "SPEEDING UP BY 10MS"
speed FCB 250 ; default wait speed if not set.
song FCB 78,2,170,2,125,2,193,2,147,2,204,2,159,2,210,2,78,2,$FF
; black $80
colors FCB $80,$8F,$9F,$AF,$BF,$CF,$DF,$EF,$FF,$01
 ORG $4000
Start:
;Main

 PSHS A,B,X,Y,CC ;save state for future return to basic.
 JSR cls

 ; Load a sequence of tone,duration values from memory and call sound in turn for each one
 LDX #song ; set pointer to song array
colorreset LDY #colors
play  LDA ,X+ ; load tone
 CMPA #$FF ; check for end of array
 BEQ endplay
 LDB ,X+ ; load duration
 PSHU B,A ;send values to U stack
 JSR sound ; Finally call the sound subroutine
 LDB ,Y+
 CMPB #$01
 BEQ colorreset
 JSR bcls
 JSR wait
 JMP play ; continue
endplay LDA #1 ; set tone to 1 and duration to 0
setup LDB #0
 PSHU B,A 
 LDA speed
 CMPA #250
 BNE endsetup ; we need to set the speed down to 100 but not hit this point later when the program is rerun.
 LDA #100
 STA speed
endsetup LDY #$400 ; set screen pointer
again  LDX #hello
; JSR wait
 JSR writesub
 LDX #line1
; JSR wait
 JSR writesub
 LDX #line2
; JSR wait
 JSR writesub
 CMPY #$400+511
 BLO again
; we finished a full run, now clear the screen and increase the speed by 10 until we have a 0ms delay
; then we fall off into RSDOS
 LDA #5
sloop JSR scroll 
 LDY #$600-32
 LDX #sctext
 JSR writesub
 DECA
 CMPA #0
 BNE sloop
 JSR cls ; clear screen.
 LDY #$400 ; reset Y or else writesub will fail.
 LDX #msg ; point to msg
 JSR writesub ; write msg
 LDA speed ; put current speed in A
 LDB #250 
 STB speed ;temp set speed to 250 before calling
 JSR wait  ;wait
 SUBA #10
 CMPA #0 ; not sure if necessary with SUBA 
 LBEQ RSDOS
 STA speed ; store original speed - 10 back to speed.
 LDX #song ;set X up correctly for the song player routine we are about to jump back into.
 JMP colorreset 

;Copied from CMOC C Library
;calls the BASIC SOUND routine from ROM.
;gets tone and duration from U stack. We save and restore U
;at start and end of this routine so it's possible to push them once and then
;continually JSR to sound and get the same tone/delay every time.
sound:
 PSHS A,B,X,U ; U is pushed because basic screws with it.
 PULU B ;tone
 STB $8C
 PULU B ;duration
 CLRA
 LSLB
 ROLA
 LSLB
 ROLA
 PSHS B,A
 LDX #$8D
 LDD ,S++
 STD ,X
 JSR $A956
 STA $ff20
 PULS A,B,X,U
 RTS

;Waste time
;based on example 12-11 of 6809 Assembly language programming
; by Lance Leventhal. 
wait:
 PSHS A,B,CC
 LDA speed
DLY1 LDB speed ; load in speed in ms
DLY DECB 
 BNE DLY
 DECA 
 BNE DLY1
 PULS A,B,CC
 RTS

;cls that just uses whatever happens to be in the B register at the time.
bcls:
 PSHS X,A
 LDX #$400
 TFR B,A
bclsloop STD ,X++
 CMPX #$600
 BLO bclsloop
 PULS X,A
 RTS
; cls subroutine that uses X and D 
; Suggested by Simon Jonassen
cls:
 LDX #$400
; LDD #$FFFF ;orange
 LDD #$8080 ;black
clsloop STD ,X++
 CMPX #$600
 BLO clsloop
 RTS



;writesub writes null terminated string pointed to by X to screen pointed to by Y
;X can point anywhere in ram Y must be between $400 and $400+511
writesub: 
 PSHS A
writeloop:
 LDA ,X+ ;grab char from string
; CMPA #00 ;check for null
 BEQ writesubreturn
 CMPY #$400+512 ;test for screen end
 BEQ writesubreturn
 JSR wait 
 JSR sound
 STA ,Y+ ;write char to screen
 JMP writeloop
writesubreturn:
 PULS A
 RTS
;memcpy slow btye at a time copy
memcpy PSHS X,Y,A,B
 PULU A 
 STA mcpylen
 PULU X ; copy target
 PULU Y ; copy source
 CLRB
memcpyloop LDA ,Y+
 STA ,X+
 INCB
 CMPB mcpylen
 BEQ memcpyret
 JMP memcpyloop
memcpyret PULS X,Y,A,B
 RTS
;scroll by one line
scroll 
 PSHS A,B,X,Y
 LDA #32
 LDX #$400 ; target 
 LDY #$400+32 ; source
scrloop PSHU Y,X,A
 JSR memcpy
 LEAX 32,X ; increment X by 32
 LEAY 32,Y ; increment Y by 32
 CMPY #$600
 BEQ scrcl ; jump to clear line code
 LDA #32
 JMP scrloop 
scrcl LEAX -32,Y ; set X to the beginning of the last line.
 LDA #$8F
scrcloop STA ,X+
 CMPX #$600
 BNE scrcloop
 PULS A,B,X,Y
 RTS

;Return to RSDOS
RSDOS PULS A,B,X,Y,CC restore state ;exit to RSDOS
 RTS return to basic 
;variables
mcpylen FCB 0
 END Start
